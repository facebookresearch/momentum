

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pymomentum.axel &mdash; PyMomentum  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pymomentum.geometry" href="geometry.html" />
    <link rel="prev" title="Welcome to PyMomentum" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyMomentum
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">pymomentum.axel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.BoundingBox"><code class="docutils literal notranslate"><span class="pre">BoundingBox</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.__init__"><code class="docutils literal notranslate"><span class="pre">BoundingBox.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.center"><code class="docutils literal notranslate"><span class="pre">BoundingBox.center</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.contains"><code class="docutils literal notranslate"><span class="pre">BoundingBox.contains()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.extend"><code class="docutils literal notranslate"><span class="pre">BoundingBox.extend()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.max"><code class="docutils literal notranslate"><span class="pre">BoundingBox.max</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.min"><code class="docutils literal notranslate"><span class="pre">BoundingBox.min</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.__init__"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.max_distance"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.max_distance</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.narrow_band_width"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.narrow_band_width</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.tolerance"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.tolerance</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.__init__"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.bounds"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.bounds</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.fill"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.fill()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.gradient"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.gradient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.grid_to_world"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.grid_to_world()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.is_valid_index"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.is_valid_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.resolution"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.resolution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.sample"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.sample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.sample_with_gradient"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.sample_with_gradient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.total_voxels"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.total_voxels</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.voxel_size"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.voxel_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.world_to_grid"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.world_to_grid()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.dual_contouring"><code class="docutils literal notranslate"><span class="pre">dual_contouring()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.fill_holes"><code class="docutils literal notranslate"><span class="pre">fill_holes()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.mesh_to_sdf"><code class="docutils literal notranslate"><span class="pre">mesh_to_sdf()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.triangulate_quads"><code class="docutils literal notranslate"><span class="pre">triangulate_quads()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="geometry.html">pymomentum.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="quaternion.html">pymomentum.quaternion</a></li>
<li class="toctree-l1"><a class="reference internal" href="skel_state.html">pymomentum.skel_state</a></li>
<li class="toctree-l1"><a class="reference internal" href="trs.html">pymomentum.trs</a></li>
<li class="toctree-l1"><a class="reference internal" href="backend.html">pymomentum.backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="solver.html">pymomentum.solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="solver2.html">pymomentum.solver2</a></li>
<li class="toctree-l1"><a class="reference internal" href="marker_tracking.html">pymomentum.marker_tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="torch.html">pymomentum.torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="renderer.html">pymomentum.renderer</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyMomentum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pymomentum.axel</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/axel.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pymomentum.axel">
<span id="pymomentum-axel"></span><h1>pymomentum.axel<a class="headerlink" href="#module-pymomentum.axel" title="Link to this heading"></a></h1>
<p>Python bindings for Axel library classes including SignedDistanceField.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">BoundingBox</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymomentum.axel.BoundingBox.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pymomentum.axel.BoundingBox, min_corner: numpy.ndarray[numpy.float32[3, 1]], max_corner: numpy.ndarray[numpy.float32[3, 1]], id: int = 0) -&gt; None</p></li>
</ol>
<p>Create a bounding box from minimum and maximum corners.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_corner</strong> – Minimum corner of the bounding box (x, y, z).</p></li>
<li><p><strong>max_corner</strong> – Maximum corner of the bounding box (x, y, z).</p></li>
<li><p><strong>id</strong> – Optional ID for the bounding box (default: 0).</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pymomentum.axel.BoundingBox, center: numpy.ndarray[numpy.float32[3, 1]], thickness: float = 0.0) -&gt; None</p></li>
</ol>
<p>Create a bounding box centered at a point with given thickness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – Center point of the bounding box (x, y, z).</p></li>
<li><p><strong>thickness</strong> – Half-width in each dimension (default: 0.0).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.center">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.center" title="Link to this definition"></a></dt>
<dd><p>Get the center of the bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><span class="pre">pymomentum.axel.BoundingBox</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.contains" title="Link to this definition"></a></dt>
<dd><p>Check if a point is contained within the bounding box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> – Point to test (x, y, z).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the point is inside the bounding box.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><span class="pre">pymomentum.axel.BoundingBox</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.extend" title="Link to this definition"></a></dt>
<dd><p>Extend the bounding box to include a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> – Point to include (x, y, z).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.max">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.max" title="Link to this definition"></a></dt>
<dd><p>Get the maximum corner of the bounding box.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.min">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">min</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.min" title="Link to this definition"></a></dt>
<dd><p>Get the minimum corner of the bounding box.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">MeshToSdfConfig</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig" title="pymomentum.axel.MeshToSdfConfig"><span class="pre">pymomentum.axel.MeshToSdfConfig</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.__init__" title="Link to this definition"></a></dt>
<dd><p>Create MeshToSdfConfig with default parameters.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.max_distance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_distance</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.max_distance" title="Link to this definition"></a></dt>
<dd><p>Maximum distance to compute (distances beyond this are clamped). Set to 0 to disable clamping. Default: 0</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.narrow_band_width">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">narrow_band_width</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.narrow_band_width" title="Link to this definition"></a></dt>
<dd><p>Narrow band width around triangles (in voxel units). Default: 1.5</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.tolerance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tolerance</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.tolerance" title="Link to this definition"></a></dt>
<dd><p>Numerical tolerance for computations. Default: machine epsilon * 1000</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">SignedDistanceField</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pymomentum.axel.SignedDistanceField, bounds: pymomentum.axel.BoundingBox, resolution: numpy.ndarray[numpy.int32[3, 1]], initial_value: float = 3.4028234663852886e+38) -&gt; None</p></li>
</ol>
<p>Create a signed distance field with given bounds and resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – 3D bounding box defining the spatial extent of the SDF.</p></li>
<li><p><strong>resolution</strong> – Grid resolution in each dimension (nx, ny, nz).</p></li>
<li><p><strong>initial_value</strong> – Initial distance value for all voxels (default: very far distance).</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pymomentum.axel.SignedDistanceField, bounds: pymomentum.axel.BoundingBox, resolution: numpy.ndarray[numpy.int32[3, 1]], data: list[float]) -&gt; None</p></li>
</ol>
<p>Create a signed distance field with given bounds, resolution, and initial data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – 3D bounding box defining the spatial extent of the SDF.</p></li>
<li><p><strong>resolution</strong> – Grid resolution in each dimension (nx, ny, nz).</p></li>
<li><p><strong>data</strong> – Initial distance values. Must have size nx * ny * nz.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.bounds">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bounds</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.bounds" title="Link to this definition"></a></dt>
<dd><p>Get the bounding box of the SDF.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.fill" title="Link to this definition"></a></dt>
<dd><p>Fill the entire SDF with a constant value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> – The value to fill with.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.gradient" title="Link to this definition"></a></dt>
<dd><p>Sample the SDF gradient at continuous 3D positions.</p>
<p>Supports both single position and batch operations:
- Single position: Pass 1D array of shape (3,) to get a 1D array of shape (3,)
- Batch positions: Pass 2D array of shape (N, 3) to get 2D array of shape (N, 3)</p>
<p>The gradient points in the direction of increasing distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> – Position(s) to query. Either (3,) for single position or (N, 3) for batch of positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Gradient vector(s) at the given position(s). Shape (3,) for single position, (N, 3) for batch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.grid_to_world">
<span class="sig-name descname"><span class="pre">grid_to_world</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_pos</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.grid_to_world" title="Link to this definition"></a></dt>
<dd><p>Convert continuous grid coordinates to 3D world-space position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>grid_pos</strong> – Continuous grid coordinates.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>3D world-space position (x, y, z).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.is_valid_index">
<span class="sig-name descname"><span class="pre">is_valid_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.is_valid_index" title="Link to this definition"></a></dt>
<dd><p>Check if the given grid coordinates are within bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – Grid index in x dimension.</p></li>
<li><p><strong>j</strong> – Grid index in y dimension.</p></li>
<li><p><strong>k</strong> – Grid index in z dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if indices are within valid range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.resolution">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resolution</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.resolution" title="Link to this definition"></a></dt>
<dd><p>Get the grid resolution as (nx, ny, nz).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.sample" title="Link to this definition"></a></dt>
<dd><p>Sample the SDF at continuous 3D positions using trilinear interpolation.</p>
<p>Supports both single position and batch operations:
- Single position: Pass 1D array of shape (3,) to get a scalar result
- Batch positions: Pass 2D array of shape (N, 3) to get 1D array of N results</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> – Position(s) to query. Either (3,) for single position or (N, 3) for batch of positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Interpolated signed distance value(s). Scalar for single position, 1D array for batch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.sample_with_gradient">
<span class="sig-name descname"><span class="pre">sample_with_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.sample_with_gradient" title="Link to this definition"></a></dt>
<dd><p>Sample both the SDF value and gradient at continuous 3D positions.</p>
<p>Supports both single position and batch operations:
- Single position: Pass 1D array of shape (3,) to get tuple of (scalar, 1D array of shape (3,))
- Batch positions: Pass 2D array of shape (N, 3) to get tuple of (1D array of N values, 2D array of shape (N, 3))</p>
<p>More efficient than calling sample() and gradient() separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> – Position(s) to query. Either (3,) for single position or (N, 3) for batch of positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (value(s), gradient(s)) at the given position(s).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.total_voxels">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_voxels</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.total_voxels" title="Link to this definition"></a></dt>
<dd><p>Get the total number of voxels in the SDF.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.voxel_size">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">voxel_size</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.voxel_size" title="Link to this definition"></a></dt>
<dd><p>Get the voxel size in each dimension as (dx, dy, dz).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.world_to_grid">
<span class="sig-name descname"><span class="pre">world_to_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.world_to_grid" title="Link to this definition"></a></dt>
<dd><p>Convert a 3D world-space position to continuous grid coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>position</strong> – 3D world-space position (x, y, z).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Continuous grid coordinates (may be fractional).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.dual_contouring">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">dual_contouring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sdf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">isovalue</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangulate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.dual_contouring" title="Link to this definition"></a></dt>
<dd><p>Extract an isosurface from a signed distance field using dual contouring.</p>
<p>Dual contouring places vertices inside grid cells and generates quad faces between
adjacent cells that both contain vertices. This naturally produces quads rather than
triangles, which better preserves surface topology and reduces mesh artifacts.</p>
<p>The algorithm works by:
1. Finding all cells that intersect the isosurface (sign changes across cell corners)
2. Placing one vertex at each intersecting cell, positioned on the surface using gradient descent
3. Generating quads for each edge crossing that connects 4 adjacent cells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sdf</strong> – The <a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a> to extract the isosurface from.</p></li>
<li><p><strong>isovalue</strong> – The isovalue to extract (typically 0.0 for zero level set). Default: 0.0</p></li>
<li><p><strong>triangulate</strong> – Whether to triangulate the quads (default: False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (vertices, normals, quads) where:
- vertices: 2D array of shape (N, 3) with vertex positions
- normals: 2D array of shape (N, 3) with vertex normals (computed from SDF gradients)
- quads: Quad indices of shape (M, 4) connecting the vertices</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a sphere SDF</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">BoundingBox</span><span class="p">(</span>
    <span class="n">min_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">]),</span>
    <span class="n">max_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">])</span>
<span class="n">sdf</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">SignedDistanceField</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>

<span class="c1"># Fill with sphere distance values</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">grid_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">world_pos</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">grid_to_world</span><span class="p">(</span><span class="n">grid_pos</span><span class="p">)</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">world_pos</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>  <span class="c1"># Unit sphere</span>
            <span class="n">sdf</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>

<span class="c1"># Extract mesh (always returns quads)</span>
<span class="n">vertices</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">dual_contouring</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">isovalue</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span><span class="si">}</span><span class="s2"> quads&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Vertex normals have shape: </span><span class="si">{</span><span class="n">normals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.fill_holes">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">fill_holes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.fill_holes" title="Link to this definition"></a></dt>
<dd><p>Fill holes in a triangle mesh to create a watertight surface.</p>
<p>This function identifies holes in the mesh and fills them with new triangles using
an advancing front method. The result is a complete mesh suitable for operations
that require watertight surfaces, such as SDF generation.</p>
<p>For small holes (≤6 vertices), a centroid-based fan triangulation is used.
For larger holes, an ear clipping algorithm is applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.
Indices must be valid within the vertices array.</p></li>
<li><p><strong>config</strong> – Configuration parameters as <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshHoleFillingConfig</span></code> (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (filled_vertices, filled_triangles) where:
- filled_vertices: 2D array of shape (N’, 3) with original + new vertices
- filled_triangles: 2D array of shape (M’, 3) with original + new triangles</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a cube mesh with a missing face (hole)</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>   <span class="c1"># top face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Missing top face triangles to create a hole</span>
<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="c1"># [4, 7, 6], [4, 6, 5],  # top face (missing - creates hole)</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># front face</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># back face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  <span class="c1"># left face</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>   <span class="c1"># right face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">MeshHoleFillingConfig</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">max_edge_length_ratio</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">config</span><span class="o">.</span><span class="n">smoothing_iterations</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">filled_vertices</span><span class="p">,</span> <span class="n">filled_triangles</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original mesh: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span><span class="si">}</span><span class="s2"> triangles&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled mesh: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filled_vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filled_triangles</span><span class="p">)</span><span class="si">}</span><span class="s2"> triangles&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.mesh_to_sdf">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">mesh_to_sdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymomentum.axel.mesh_to_sdf" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>mesh_to_sdf(vertices: numpy.ndarray[numpy.float32], triangles: numpy.ndarray[numpy.int32], bounds: pymomentum.axel.BoundingBox, resolution: numpy.ndarray[numpy.int32], config: pymomentum.axel.MeshToSdfConfig = MeshToSdfConfig(narrow_band_width=1.500, max_distance=0.000, tolerance=1.192093e-04)) -&gt; pymomentum.axel.SignedDistanceField</p></li>
</ol>
<p>Convert a triangle mesh to a signed distance field using modern 3-step approach.</p>
<p>This function creates a high-quality signed distance field from a triangle mesh using:
1. Narrow band initialization with exact triangle distances
2. Fast marching propagation using Eikonal equation
3. Sign determination using ray casting</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.
Indices must be valid within the vertices array.</p></li>
<li><p><strong>bounds</strong> – Spatial bounds for the SDF as a <a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundingBox</span></code></a>.</p></li>
<li><p><strong>resolution</strong> – Grid resolution as 1D array of shape (3,) containing (nx, ny, nz).</p></li>
<li><p><strong>config</strong> – Configuration parameters as <a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig" title="pymomentum.axel.MeshToSdfConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshToSdfConfig</span></code></a> (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated <a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a>.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a simple cube mesh</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>   <span class="c1"># top face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>  <span class="c1"># top face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># front face</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># back face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  <span class="c1"># left face</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>   <span class="c1"># right face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">bounds</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">BoundingBox</span><span class="p">(</span>
    <span class="n">min_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]),</span>
    <span class="n">max_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">])</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">MeshToSdfConfig</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">narrow_band_width</span> <span class="o">=</span> <span class="mf">3.0</span>

<span class="n">sdf</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">mesh_to_sdf</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>mesh_to_sdf(vertices: numpy.ndarray[numpy.float32], triangles: numpy.ndarray[numpy.int32], resolution: numpy.ndarray[numpy.int32], padding: float = 0.10000000149011612, config: pymomentum.axel.MeshToSdfConfig = MeshToSdfConfig(narrow_band_width=1.500, max_distance=0.000, tolerance=1.192093e-04)) -&gt; pymomentum.axel.SignedDistanceField</p></li>
</ol>
<p>Convert a triangle mesh to a signed distance field with automatic bounds computation.</p>
<p>This convenience function automatically computes the bounding box from the mesh vertices,
adds padding, and creates a signed distance field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.</p></li>
<li><p><strong>resolution</strong> – Grid resolution as 1D array of shape (3,) containing (nx, ny, nz).</p></li>
<li><p><strong>padding</strong> – Extra space around mesh bounds as fraction of bounding box size (default: 0.1).</p></li>
<li><p><strong>config</strong> – Configuration parameters as <a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig" title="pymomentum.axel.MeshToSdfConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshToSdfConfig</span></code></a> (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated <a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a>.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a simple tetrahedron mesh</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">])</span>

<span class="c1"># Automatically compute bounds with 20% padding</span>
<span class="n">sdf</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">mesh_to_sdf</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.triangulate_quads">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">triangulate_quads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.triangulate_quads" title="Link to this definition"></a></dt>
<dd><p>Triangulate a quad mesh into triangles.</p>
<p>Each quad is split into two triangles using the diagonal (0,2).
This converts a quad mesh (as produced by dual contouring) into a triangle mesh
suitable for rendering or processing with triangle-based algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quads</strong> – Quad indices as 2D array of shape (M, 4) where M is number of quads.
Each row contains 4 vertex indices defining a quad.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Triangle indices as 2D array of shape (2M, 3) where each quad produces 2 triangles.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Get quads from dual contouring</span>
<span class="n">vertices</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">dual_contouring</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>

<span class="c1"># Convert to triangles if needed for rendering</span>
<span class="n">triangles</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">triangulate_quads</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span><span class="si">}</span><span class="s2"> quads to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span><span class="si">}</span><span class="s2"> triangles&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to PyMomentum" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="geometry.html" class="btn btn-neutral float-right" title="pymomentum.geometry" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>