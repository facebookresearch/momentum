

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pymomentum.quaternion &mdash; PyMomentum  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pymomentum.skel_state" href="skel_state.html" />
    <link rel="prev" title="pymomentum.geometry" href="geometry.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyMomentum
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="geometry.html">pymomentum.geometry</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pymomentum.quaternion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#quaternion-utilities">Quaternion Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quaternion-format">Quaternion Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-operations">Core Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.blend"><code class="docutils literal notranslate"><span class="pre">blend()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.check"><code class="docutils literal notranslate"><span class="pre">check()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.check_and_normalize_weights"><code class="docutils literal notranslate"><span class="pre">check_and_normalize_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.conjugate"><code class="docutils literal notranslate"><span class="pre">conjugate()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.euler_xyz_to_quaternion"><code class="docutils literal notranslate"><span class="pre">euler_xyz_to_quaternion()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.euler_zyx_to_quaternion"><code class="docutils literal notranslate"><span class="pre">euler_zyx_to_quaternion()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.from_axis_angle"><code class="docutils literal notranslate"><span class="pre">from_axis_angle()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.from_rotation_matrix"><code class="docutils literal notranslate"><span class="pre">from_rotation_matrix()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.from_two_vectors"><code class="docutils literal notranslate"><span class="pre">from_two_vectors()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.identity"><code class="docutils literal notranslate"><span class="pre">identity()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.inverse"><code class="docutils literal notranslate"><span class="pre">inverse()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.multiply"><code class="docutils literal notranslate"><span class="pre">multiply()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.multiply_assume_normalized"><code class="docutils literal notranslate"><span class="pre">multiply_assume_normalized()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.multiply_backprop"><code class="docutils literal notranslate"><span class="pre">multiply_backprop()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.multiply_backprop_assume_normalized"><code class="docutils literal notranslate"><span class="pre">multiply_backprop_assume_normalized()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.normalize"><code class="docutils literal notranslate"><span class="pre">normalize()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.normalize_backprop"><code class="docutils literal notranslate"><span class="pre">normalize_backprop()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.quaternion_to_xyz_euler"><code class="docutils literal notranslate"><span class="pre">quaternion_to_xyz_euler()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.rotate_vector"><code class="docutils literal notranslate"><span class="pre">rotate_vector()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.rotate_vector_assume_normalized"><code class="docutils literal notranslate"><span class="pre">rotate_vector_assume_normalized()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.rotate_vector_backprop"><code class="docutils literal notranslate"><span class="pre">rotate_vector_backprop()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.rotate_vector_backprop_assume_normalized"><code class="docutils literal notranslate"><span class="pre">rotate_vector_backprop_assume_normalized()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.slerp"><code class="docutils literal notranslate"><span class="pre">slerp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.quaternion.to_rotation_matrix"><code class="docutils literal notranslate"><span class="pre">to_rotation_matrix()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="skel_state.html">pymomentum.skel_state</a></li>
<li class="toctree-l1"><a class="reference internal" href="trs.html">pymomentum.trs</a></li>
<li class="toctree-l1"><a class="reference internal" href="solver.html">pymomentum.solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="solver2.html">pymomentum.solver2</a></li>
<li class="toctree-l1"><a class="reference internal" href="marker_tracking.html">pymomentum.marker_tracking</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyMomentum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pymomentum.quaternion</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/quaternion.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pymomentum.quaternion">
<span id="pymomentum-quaternion"></span><h1>pymomentum.quaternion<a class="headerlink" href="#module-pymomentum.quaternion" title="Link to this heading"></a></h1>
<section id="quaternion-utilities">
<h2>Quaternion Utilities<a class="headerlink" href="#quaternion-utilities" title="Link to this heading"></a></h2>
<p>This module provides comprehensive utilities for working with quaternions in PyMomentum.</p>
<p>Quaternions are a mathematical representation of rotations in 3D space that offer several
advantages over other rotation representations like Euler angles or rotation matrices:</p>
<ul class="simple">
<li><p><strong>No gimbal lock</strong>: Unlike Euler angles, quaternions don’t suffer from singularities</p></li>
<li><p><strong>Compact representation</strong>: Only 4 components vs 9 for rotation matrices</p></li>
<li><p><strong>Efficient composition</strong>: Quaternion multiplication is faster than matrix multiplication</p></li>
<li><p><strong>Smooth interpolation</strong>: SLERP provides natural rotation interpolation</p></li>
</ul>
<section id="quaternion-format">
<h3>Quaternion Format<a class="headerlink" href="#quaternion-format" title="Link to this heading"></a></h3>
<p>This module uses the (x, y, z, w) format where:</p>
<ul class="simple">
<li><p><strong>(x, y, z)</strong>: Vector part representing the rotation axis scaled by sin(θ/2)</p></li>
<li><p><strong>w</strong>: Scalar part representing cos(θ/2), where θ is the rotation angle</p></li>
</ul>
<p>The identity quaternion is (0, 0, 0, 1), representing no rotation.</p>
</section>
<section id="core-operations">
<h3>Core Operations<a class="headerlink" href="#core-operations" title="Link to this heading"></a></h3>
<p>The module provides functions for:</p>
<ul class="simple">
<li><p><strong>Basic operations</strong>: <a class="reference internal" href="#pymomentum.quaternion.multiply" title="pymomentum.quaternion.multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.conjugate" title="pymomentum.quaternion.conjugate"><code class="xref py py-func docutils literal notranslate"><span class="pre">conjugate()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.inverse" title="pymomentum.quaternion.inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">inverse()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.normalize" title="pymomentum.quaternion.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">normalize()</span></code></a></p></li>
<li><p><strong>Conversions</strong>: <a class="reference internal" href="#pymomentum.quaternion.from_axis_angle" title="pymomentum.quaternion.from_axis_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">from_axis_angle()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.euler_xyz_to_quaternion" title="pymomentum.quaternion.euler_xyz_to_quaternion"><code class="xref py py-func docutils literal notranslate"><span class="pre">euler_xyz_to_quaternion()</span></code></a>,
<a class="reference internal" href="#pymomentum.quaternion.from_rotation_matrix" title="pymomentum.quaternion.from_rotation_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">from_rotation_matrix()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.to_rotation_matrix" title="pymomentum.quaternion.to_rotation_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_rotation_matrix()</span></code></a></p></li>
<li><p><strong>Vector operations</strong>: <a class="reference internal" href="#pymomentum.quaternion.rotate_vector" title="pymomentum.quaternion.rotate_vector"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate_vector()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.from_two_vectors" title="pymomentum.quaternion.from_two_vectors"><code class="xref py py-func docutils literal notranslate"><span class="pre">from_two_vectors()</span></code></a></p></li>
<li><p><strong>Interpolation</strong>: <a class="reference internal" href="#pymomentum.quaternion.slerp" title="pymomentum.quaternion.slerp"><code class="xref py py-func docutils literal notranslate"><span class="pre">slerp()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.blend" title="pymomentum.quaternion.blend"><code class="xref py py-func docutils literal notranslate"><span class="pre">blend()</span></code></a></p></li>
<li><p><strong>Utilities</strong>: <a class="reference internal" href="#pymomentum.quaternion.check" title="pymomentum.quaternion.check"><code class="xref py py-func docutils literal notranslate"><span class="pre">check()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.split" title="pymomentum.quaternion.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>, <a class="reference internal" href="#pymomentum.quaternion.identity" title="pymomentum.quaternion.identity"><code class="xref py py-func docutils literal notranslate"><span class="pre">identity()</span></code></a></p></li>
</ul>
<dl>
<dt>Example:</dt><dd><p>Basic quaternion operations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymomentum</span><span class="w"> </span><span class="kn">import</span> <span class="n">quaternion</span>

<span class="c1"># Create identity quaternion</span>
<span class="n">q_identity</span> <span class="o">=</span> <span class="n">quaternion</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>

<span class="c1"># Create quaternion from axis-angle</span>
<span class="n">axis_angle</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.57</span><span class="p">])</span>  <span class="c1"># 90° rotation around Z</span>
<span class="n">q_rot</span> <span class="o">=</span> <span class="n">quaternion</span><span class="o">.</span><span class="n">from_axis_angle</span><span class="p">(</span><span class="n">axis_angle</span><span class="p">)</span>

<span class="c1"># Rotate a vector</span>
<span class="n">vector</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">rotated</span> <span class="o">=</span> <span class="n">quaternion</span><span class="o">.</span><span class="n">rotate_vector</span><span class="p">(</span><span class="n">q_rot</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>

<span class="c1"># Interpolate between quaternions</span>
<span class="n">q_interp</span> <span class="o">=</span> <span class="n">quaternion</span><span class="o">.</span><span class="n">slerp</span><span class="p">(</span><span class="n">q_identity</span><span class="p">,</span> <span class="n">q_rot</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Note:</dt><dd><p>All functions expect quaternions as PyTorch tensors with the last dimension
having size 4, following the (x, y, z, w) format. Most functions support
batched operations for efficient processing of multiple quaternions.</p>
</dd>
</dl>
</section>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.blend">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">blend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quaternions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.blend" title="Link to this definition"></a></dt>
<dd><p>Blend multiple quaternions together using the method described in
<a class="reference external" href="https://stackoverflow.com/questions/12374087/average-of-multiple-quaternions">https://stackoverflow.com/questions/12374087/average-of-multiple-quaternions</a>
and <a class="reference external" href="http://www.acsu.buffalo.edu/~johnc/ave_quat07.pdf">http://www.acsu.buffalo.edu/~johnc/ave_quat07.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quaternions</strong> – A tensor of shape (…, k, 4) representing the quaternions to blend.</p></li>
<li><p><strong>weights_in</strong> – An optional tensor of shape (…, k) representing the weights for each quaternion.
If not provided, all quaternions will be weighted equally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of shape (…, 4) representing the blended quaternion.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.check">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.quaternion.check" title="Link to this definition"></a></dt>
<dd><p>Check if a tensor represents a quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> – A tensor representing a quaternion.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.check_and_normalize_weights">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">check_and_normalize_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quaternions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.check_and_normalize_weights" title="Link to this definition"></a></dt>
<dd><p>Check and normalize the weights for blending quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quaternions</strong> – A tensor of shape (…, k, 4) representing the quaternions to blend.</p></li>
<li><p><strong>weights_in</strong> – An optional tensor of shape (…, k) representing the weights for each quaternion.
If not provided, all quaternions will be weighted equally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of shape (…, k) representing the normalized weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.conjugate">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.conjugate" title="Link to this definition"></a></dt>
<dd><p>Conjugate a quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> – A quaternion ((x, y, z), w)).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The conjugate.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.euler_xyz_to_quaternion">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">euler_xyz_to_quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">euler_xyz</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.euler_xyz_to_quaternion" title="Link to this definition"></a></dt>
<dd><p>Convert Euler XYZ angles to a quaternion.</p>
<p>This function converts XYZ Euler angles to quaternions.
The rotation order is X-Y-Z, meaning first rotate around X-axis, then Y-axis,
then Z-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>euler_xyz</strong> – A tensor of shape (…, 3) representing the Euler XYZ angles
in order [roll, pitch, yaw].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of shape (…, 4) representing the quaternion in ((x, y, z), w) format.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.euler_zyx_to_quaternion">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">euler_zyx_to_quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">euler_zyx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.euler_zyx_to_quaternion" title="Link to this definition"></a></dt>
<dd><p>Convert Euler ZYX angles to a quaternion.</p>
<p>This function converts ZYX Euler angles (yaw-pitch-roll convention) to quaternions.
The rotation order is Z-Y-X, meaning first rotate around Z-axis (yaw), then Y-axis (pitch),
then X-axis (roll).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>euler_zyx</strong> – A tensor of shape (…, 3) representing the Euler ZYX angles
in order [yaw, pitch, roll].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of shape (…, 4) representing the quaternion in ((x, y, z), w) format.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.from_axis_angle">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">from_axis_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis_angle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.from_axis_angle" title="Link to this definition"></a></dt>
<dd><p>Convert an axis-angle tensor to a quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>axis_angle</strong> – A tensor of shape (…, 3) representing the axis-angle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of shape (…, 4) representing the quaternion in ((x, y, z), w) format.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.from_rotation_matrix">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">from_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.from_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Convert a rotation matrix to a quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrices</strong> – A tensor of shape (…, 3, 3) representing the rotation matrices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of shape (…, 4) representing the quaternions in ((x, y, z), w) format.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.from_two_vectors">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">from_two_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.from_two_vectors" title="Link to this definition"></a></dt>
<dd><p>Construct a quaternion that rotates one vector into another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – The initial vector.</p></li>
<li><p><strong>v2</strong> – The target vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A quaternion representing the rotation from v1 to v2.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.identity">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dtype</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">torch.float32</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.identity" title="Link to this definition"></a></dt>
<dd><p>Create a quaternion identity tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sizes</strong> – A tuple of integers representing the size of the quaternion tensor.</p></li>
<li><p><strong>device</strong> – The device on which to create the tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A quaternion identity tensor with the specified sizes and device.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.inverse">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.inverse" title="Link to this definition"></a></dt>
<dd><p>Compute the inverse of a quaternion.</p>
<p>Uses numerical clamping to avoid division by very small numbers,
improving numerical stability for near-zero quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> – A quaternion ((x, y, z), w)).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inverse.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.multiply">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.multiply" title="Link to this definition"></a></dt>
<dd><p>Multiply two quaternions together.</p>
<p>Normalizes input quaternions before multiplication for numerical stability.
For performance-critical code where quaternions are guaranteed to be normalized,
use <a class="reference internal" href="#pymomentum.quaternion.multiply_assume_normalized" title="pymomentum.quaternion.multiply_assume_normalized"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply_assume_normalized()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q1</strong> – A quaternion ((x, y, z), w)).</p></li>
<li><p><strong>q2</strong> – A quaternion ((x, y, z), w)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The normalized product q1*q2.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.multiply_assume_normalized">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">multiply_assume_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.multiply_assume_normalized" title="Link to this definition"></a></dt>
<dd><p>Multiply two quaternions together, assuming they are already normalized.</p>
<p>This is a performance-optimized version of <a class="reference internal" href="#pymomentum.quaternion.multiply" title="pymomentum.quaternion.multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code></a> that skips
normalization of the input quaternions. Use this only when you are certain
both quaternions are already normalized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q1</strong> – A normalized quaternion ((x, y, z), w)).</p></li>
<li><p><strong>q2</strong> – A normalized quaternion ((x, y, z), w)).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The product q1*q2.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.multiply_backprop">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">multiply_backprop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.quaternion.multiply_backprop" title="Link to this definition"></a></dt>
<dd><p>Custom backpropagation for quaternion multiplication.</p>
<p>Computes gradients for quaternion multiplication with proper handling of
normalization.</p>
<p>This version normalizes the input quaternions. For performance-critical code
where quaternions are guaranteed to be normalized, use
<a class="reference internal" href="#pymomentum.quaternion.multiply_backprop_assume_normalized" title="pymomentum.quaternion.multiply_backprop_assume_normalized"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply_backprop_assume_normalized()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q1</strong> – The first quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>q2</strong> – The second quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>grad_q</strong> – The gradient from the output of shape (…, 4).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of (grad_q1, grad_q2) representing gradients with respect
to the first and second quaternions respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.multiply_backprop_assume_normalized">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">multiply_backprop_assume_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.quaternion.multiply_backprop_assume_normalized" title="Link to this definition"></a></dt>
<dd><p>Custom backpropagation for quaternion multiplication assuming unit quaternions.</p>
<p>Computes gradients for quaternion multiplication when both input quaternions
are assumed to be normalized. This is more efficient than the general case
but should only be used when quaternions are guaranteed to be unit quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q1</strong> – The first normalized quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>q2</strong> – The second normalized quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>grad_q</strong> – The gradient from the output of shape (…, 4).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of (grad_q1, grad_q2) representing gradients with respect
to the first and second quaternions respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.normalize">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.normalize" title="Link to this definition"></a></dt>
<dd><p>Normalize a quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> – A quaternion ((x, y, z), w)).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The normalized quaternion.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.normalize_backprop">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">normalize_backprop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.normalize_backprop" title="Link to this definition"></a></dt>
<dd><p>Custom backpropagation for quaternion normalization.</p>
<p>This function computes gradients for quaternion normalization in a numerically
stable way, avoiding potential issues with automatic differentiation when
quaternions are near zero norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – The input quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>grad</strong> – The gradient from the output of shape (…, 4).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The gradient with respect to the input quaternion q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.quaternion_to_xyz_euler">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">quaternion_to_xyz_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.quaternion_to_xyz_euler" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eps</strong> – a small number to avoid calling asin(1) or asin(-1).
Should not be smaller than 1e-6 as this can cause NaN gradients for some models.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.rotate_vector">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">rotate_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.rotate_vector" title="Link to this definition"></a></dt>
<dd><p>Rotate a vector by a quaternion.</p>
<p>Normalizes the input quaternion before rotation for numerical stability.
For performance-critical code where quaternions are guaranteed to be normalized,
use <a class="reference internal" href="#pymomentum.quaternion.rotate_vector_assume_normalized" title="pymomentum.quaternion.rotate_vector_assume_normalized"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate_vector_assume_normalized()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – (nBatch x k x 4) tensor with the quaternions in ((x, y, z), w) format.</p></li>
<li><p><strong>v</strong> – (nBatch x k x 3) vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nBatch x k x 3) rotated vectors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.rotate_vector_assume_normalized">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">rotate_vector_assume_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.rotate_vector_assume_normalized" title="Link to this definition"></a></dt>
<dd><p>Rotate a vector by a quaternion, assuming the quaternion is already normalized.</p>
<p>This is a performance-optimized version of <a class="reference internal" href="#pymomentum.quaternion.rotate_vector" title="pymomentum.quaternion.rotate_vector"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate_vector()</span></code></a> that skips
normalization of the input quaternion. Use this only when you are certain
the quaternion is already normalized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – (nBatch x k x 4) tensor with normalized quaternions in ((x, y, z), w) format.</p></li>
<li><p><strong>v</strong> – (nBatch x k x 3) vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nBatch x k x 3) rotated vectors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.rotate_vector_backprop">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">rotate_vector_backprop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.quaternion.rotate_vector_backprop" title="Link to this definition"></a></dt>
<dd><p>Custom backpropagation for quaternion vector rotation.</p>
<p>Computes gradients for the quaternion rotation operation using the
Euler-Rodrigues formula.</p>
<p>This version normalizes the input quaternion. For performance-critical code
where quaternions are guaranteed to be normalized, use
<a class="reference internal" href="#pymomentum.quaternion.rotate_vector_backprop_assume_normalized" title="pymomentum.quaternion.rotate_vector_backprop_assume_normalized"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate_vector_backprop_assume_normalized()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – The quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>v</strong> – The vector tensor of shape (…, 3).</p></li>
<li><p><strong>grad</strong> – The gradient from the output of shape (…, 3).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of (grad_q, grad_v) representing gradients with respect
to the quaternion and vector respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.rotate_vector_backprop_assume_normalized">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">rotate_vector_backprop_assume_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.quaternion.rotate_vector_backprop_assume_normalized" title="Link to this definition"></a></dt>
<dd><p>Custom backpropagation for quaternion vector rotation assuming unit quaternions.</p>
<p>This is a performance-optimized version of <a class="reference internal" href="#pymomentum.quaternion.rotate_vector_backprop" title="pymomentum.quaternion.rotate_vector_backprop"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate_vector_backprop()</span></code></a> that
assumes the input quaternion is already normalized. Use this only when you are
certain the quaternion is normalized to avoid numerical issues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – The normalized quaternion tensor of shape (…, 4).</p></li>
<li><p><strong>v</strong> – The vector tensor of shape (…, 3).</p></li>
<li><p><strong>grad</strong> – The gradient from the output of shape (…, 3).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of (grad_q, grad_v) representing gradients with respect
to the quaternion and vector respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.slerp">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.slerp" title="Link to this definition"></a></dt>
<dd><p>Perform spherical linear interpolation (slerp) between two quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q0</strong> – The starting quaternion.</p></li>
<li><p><strong>q1</strong> – The ending quaternion.</p></li>
<li><p><strong>t</strong> – The interpolation parameter, where 0 &lt;= t &lt;= 1.  t=0 corresponds to q0, t=1 corresponds to q1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated quaternion.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.split">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.quaternion.split" title="Link to this definition"></a></dt>
<dd><p>Split a quaternion into its scalar and vector parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> – A tensor representing a quaternion.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The scalar and vector parts of the quaternion.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.quaternion.to_rotation_matrix">
<span class="sig-prename descclassname"><span class="pre">pymomentum.quaternion.</span></span><span class="sig-name descname"><span class="pre">to_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#pymomentum.quaternion.to_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Convert quaternions to 3x3 rotation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> – (nBatch x k x 4) tensor with the quaternions in ((x, y, z), w) format.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nBatch x k x 3 x 3) tensor with 3x3 rotation matrices.</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="geometry.html" class="btn btn-neutral float-left" title="pymomentum.geometry" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="skel_state.html" class="btn btn-neutral float-right" title="pymomentum.skel_state" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>